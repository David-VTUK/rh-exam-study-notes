{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"RH Exam Revision Notes","text":"<ul> <li>EX188</li> </ul>"},{"location":"ex188/01-implement-images-using-podman/","title":"Implement images using Podman","text":""},{"location":"ex188/01-implement-images-using-podman/#understand-and-use-from-the-concept-of-a-base-image-instruction","title":"Understand and use FROM (the concept of a base image) instruction","text":"<p><code>FROM</code> serves as a starting point for building a container image. It specifies the <code>base image</code> to use for the image. This base image is typically a lightweight version of an operating system like Ubuntu, Alpine, or even a minimal image that contains only the bare essentials needed for an application to run.</p> <p>Example:</p> <pre><code>FROM alpine:3.18.5\n</code></pre> <p>Specifies the image will be using the <code>alpine:3.18.5</code> image as its base. Represented as <code>name:version(aka tag)</code></p> <p>Other key characteristics of <code>FROM</code> include:</p> <p>Layering - Every instruction in a Dockerfile will result in a <code>layer</code> when the image is built. This is partly why we specify a base image first - it provides us with a foundation to add further components to the image.</p> <p>Multi Stage Container - You can have multiple <code>FROM</code> declarations in a container image - these are used in multi-staged builds. This is useful for creating lightweight images by compiling or building your application in a first stage with all necessary build tools, and then copying the relevant artifacts into a second stage with a leaner base image.</p> <p>Efficiency and Security - Selecting (or building) an appropriate base image is crucial for the efficiency and security of the container image. A minimal base image reduces the size of the image and also minimizes the attack service, as there are fewer components that could contain vulnerabilities compared to a fully fledged, general purpose Operating System.</p> <p>Example Multi Stage Build:</p> <pre><code># Stage 1: Building the code\nFROM node:14 as builder\n\n# Create app directory\nWORKDIR /usr/src/app\n\n# Install app dependencies\nCOPY package*.json ./\nRUN npm install\n\n# Bundle app source\nCOPY . .\n\n# Build the application\nRUN npm run build\n\n# Stage 2: Setup the production environment\nFROM node:14-alpine\n\n# Set the working directory\nWORKDIR /usr/src/app\n\n# Copy package.json and package-lock.json\nCOPY package*.json ./\n\n# Install only production dependencies\nRUN npm install --only=production\n\n# Copy built assets from the builder stage\nCOPY --from=builder /usr/src/app/dist ./dist\n\n# Your app runs on port 3000\nEXPOSE 3000\n\n# Start the app\nCMD [\"node\", \"dist/main.js\"]\n</code></pre> <ul> <li>Stage 1: Building code  </li> <li><code>FROM node:14 as builder</code>: this stage starts with a  Nodejs version 14 image. <code>as builder</code> part names this stage as <code>builder</code>.</li> <li>The image then copies the application's source code and its dependencies into the image and performs the build. In this case, it's a typical Node.js setup with npm install and a build command like npm run build.</li> <li>Stage 2: Setting up runtime environment</li> <li>Note this stage is using a slightly different container image, although named similarly. In this example <code>FROM node:14-alpine</code> - a more lightweight version of the node image from stage 1.</li> <li>This stage does not include the entire build environment. Instead, it only installs the production dependencies (<code>npm install --only=production</code>) and copies the built assets (dist directory) from the builder stage. This way, the final image contains only what's necessary to run the application, reducing the image size and surface area for potential vulnerabilities.</li> </ul>"},{"location":"ex188/01-implement-images-using-podman/#understand-and-use-run-instruction","title":"Understand and use RUN instruction","text":"<p><code>RUN</code> is a fundamental command used during the image building process. It allows us to execute commands in a layer above the current image and commit the results. The resulting committed layer is used in the subsequent steps in the Image definition.</p> <p><code>RUN</code> is essential for installing software, building software, altering files and running tasks necessary to set up the desired environment inside the container for our application</p> <p>Example:</p> <pre><code>FROM fedora:39\n\nRUN dnf upgrade --refresh &amp;&amp; dnf install -y $packageName\n</code></pre> <p>Key characteristics of <code>RUN</code>:</p> <ul> <li>Layering</li> <li>Each <code>RUN</code> command creates a new layer inside the container image. For efficiency, it is common to combine multiple <code>RUN</code> commands together using <code>&amp;&amp;</code>, as shown in the example above.</li> <li>Shell vs exec form</li> <li>The <code>RUN</code> command can be run in two different ways - <code>shell</code> and <code>exec</code><ul> <li>Shell method: <code>RUN &lt;command&gt;</code> - is the equivalent of invoking <code>/bin/sh -c</code> followed by the <code>&lt;command&gt;</code></li> <li>Exec method: <code>RUN [\"executable\", \"param1\", \"param2\"]</code> - This form does not invoke a shell. It's useful when you want to avoid shell string munging, and it's necessary if you want to execute software that's not a Unix shell, like Java or Python programs.</li> </ul> </li> </ul> <p>Example:</p> <pre><code># Using the shell form to update package lists and install a package (shell method)\nRUN dnf upgrade --refresh &amp;&amp; dnf install -y curl\n</code></pre> <pre><code># Invoking a python app (exec method)\nRUN [\"python\", \"/path/to/your_script.py\", \"arg1\", \"arg2\"]\n</code></pre>"},{"location":"ex188/01-implement-images-using-podman/#understand-and-use-add-instruction","title":"Understand and use ADD instruction","text":"<p><code>ADD</code> is used to copy files, directories from either a local machine building the image, or from a remote URL. <code>ADD</code> can be considered to have all the functionality of <code>COPY</code> but with more functionality.</p> <p>Key difference: <code>COPY</code> does not support remote URL's.</p> <p>Key characteristics of <code>ADD</code></p> <ul> <li> <p>Automatic Tar Extraction - If the source file being copied is a tarball in recognized compression formats (like gzip, bzip2, etc.), ADD automatically extracts the contents of the tarball into the destination directory within the container\u2019s filesystem. This is not the case with COPY, which would just copy the tar file as-is.</p> </li> <li> <p>Syntax - <code>ADD &lt;src&gt; &lt;dest&gt;</code> : Here, <code>&lt;src&gt;</code> could be a file or directory from the Dockerfile's context, or a URL. <code>&lt;dest&gt;</code> is the path where the files will be placed inside the Docker image.</p> </li> </ul> <p>Examples:</p> <pre><code># Copies a local file \"example.txt\" into the image at \"/path/in/container/\"\nADD example.txt /path/in/container/\n</code></pre> <pre><code># Copies a local directory \"config_files\" and its contents into \"/config/\" inside the image\nADD config_files /config/\n</code></pre> <pre><code># Downloads a file from a remote URL and places it in \"/path/in/container/\"\nADD https://example.com/download/somefile /path/in/container/\n</code></pre> <pre><code># Automatically extracts \"app.tar.gz\" into \"/app/\" directory inside the image\nADD app.tar.gz /app/\n</code></pre>"},{"location":"ex188/01-implement-images-using-podman/#considerations-and-best-practices","title":"Considerations and Best Practices","text":"<ul> <li> <p>Use <code>COPY</code> When Possible: Because of its additional features, ADD can lead to unexpected behavior (like automatic tar extraction) which might not be desired in all cases. Therefore, it's generally recommended to use the simpler <code>COPY</code> command when you just need to copy files from the local context without the extra features of <code>ADD</code>.</p> </li> <li> <p>Avoid Using <code>ADD</code> for Remote URLs: While <code>ADD</code> can fetch files from remote URLs, this is generally discouraged. It's better to use a tool like <code>curl</code> or <code>wget</code> in a RUN command to fetch remote files, which gives you more control over the download process (such as error handling and retries).</p> </li> <li> <p>Image Size Considerations: Be mindful of the files you add to your image. Adding unnecessary files or large files can increase the size of your image significantly.</p> </li> <li> <p>The choice between ADD and COPY depends on your specific needs. For most file-copying tasks within the Dockerfile's context, COPY is sufficient and preferable. Use ADD for its unique features when they are explicitly needed.</p> </li> </ul>"},{"location":"ex188/01-implement-images-using-podman/#understand-and-use-copy-instruction","title":"Understand and use COPY instruction","text":"<p>The <code>COPY</code> command in a Dockerfile is used to copy files and directories from the host file system into the Docker image. It is a straightforward and commonly used command in Dockerfile scripting, particularly for adding local files to the image.</p> <p><code>Copy</code> takes two parameters - a source and destination and can be used to copy individual files as well as entire directories.</p> <ul> <li> <p>The source path must be inside the context of the build (the directory where the Dockerfile is located or specified via the build context).  </p> </li> <li> <p>The destination path is inside the container's filesystem. It can be an absolute path or a path relative to <code>WORKDIR</code> if it has been set.</p> </li> </ul> <p>Example:</p> <pre><code>FROM fedora:39\n\nRUN dnf upgrade --refresh &amp;&amp; dnf install -y $packageName\n\n# Copy the contents of the folder `app` in the working directory of the dockerfile to /usr/src/app inside the container\n\nCOPY ./app /usr/src/app\n</code></pre>"},{"location":"ex188/01-implement-images-using-podman/#understand-the-difference-between-add-and-copy-instructions","title":"Understand the difference between ADD and COPY instructions","text":"<p>The <code>ADD</code> and <code>COPY</code> commands in Dockerfiles are both used to copy files from the build context into the Docker image. However, they have distinct functionalities and are suitable for different scenarios. Here are the main differences: COPY Command</p> <ul> <li>Basic Functionality: COPY is a straightforward command used to copy files and directories from the Dockerfile's context (the local file system) into the Docker image.</li> <li>Simplicity and Clarity: It is explicitly used for copying local files and does not have any additional functionality, making it clear and predictable.</li> <li>Best Practice: Docker's best practices recommend using COPY unless you specifically need the additional capabilities of ADD.</li> </ul>"},{"location":"ex188/01-implement-images-using-podman/#add-command","title":"ADD Command","text":"<ul> <li>Advanced Features: ADD has all the capabilities of COPY but also supports a couple of additional features:</li> <li>Remote URL Support: ADD can copy files from a remote URL (e.g., http:// or https://) into the image, which COPY cannot do.</li> <li> <p>Automatic Tar Extraction: ADD can automatically extract a tarball from the source directly into the destination within the image's filesystem. This extraction happens only if the tar file is in a recognized compression format (like gzip, bzip2, etc.) and is a local tar file (not a URL).</p> </li> <li> <p>Versatility but with Complexity: Because of its additional capabilities, ADD can be used for more complex tasks than COPY. However, this also means its behavior can be less predictable, especially for new users.</p> </li> <li> <p>Use with Caution: Given its additional features, ADD can potentially introduce unwanted side-effects (like unexpected network downloads or automatic extraction of files), and hence should be used carefully.</p> </li> </ul>"},{"location":"ex188/01-implement-images-using-podman/#choosing-between-copy-and-add","title":"Choosing Between COPY and ADD*","text":"<ul> <li>Use <code>COPY</code> when you simply need to copy files from your local context into the Docker image. It is straightforward and adheres to the principle of least surprise.</li> <li>Use <code>ADD</code> when you need to utilize its advanced features like fetching files from a URL or automatic tarball extraction. However, be cautious of its implications, and prefer <code>COPY</code> for most other scenarios.</li> </ul>"},{"location":"ex188/01-implement-images-using-podman/#understand-and-use-workdir-and-user-instructions","title":"Understand and use WORKDIR and USER instructions","text":"<p><code>WORKDIR</code> is used to set the working directory for subsequent commands such as <code>RUN</code>, <code>CMD</code>, <code>ENTRYPOINT</code>, <code>COPY</code> and <code>ADD</code>.</p> <p>Setting the <code>WORKDIR</code> provides context for these commands, as this provides the location it is based from.</p> <p>Examples:</p> <pre><code>FROM fedora:39\n\nRUN dnf upgrade --refresh &amp;&amp; dnf install -y $packageName\n\nWORKDIR /usr/\n\nRUN echo \"HI\" &gt;  test.txt\n</code></pre> <p>The file created will reside as /usr/test.txt</p> <pre><code>FROM fedora:39\n\nCOPY ./app /usr/src/app\n\nWORKDIR /usr/src/app\n\nRUN [\"python\", \"your_script.py\", \"arg1\", \"arg2\"] \n</code></pre> <p>This will run <code>your_script.py</code> without having to specify the absolute path</p> <p><code>USER</code> is used to set the user identity (UID) and optionally the user group (GID) for any <code>RUN</code>, <code>CMD</code>, <code>ENTRYPOINT</code>, <code>COPY</code> and <code>ADD</code> instructions.</p> <p>It's commonly used to define a specific user to run an application inside the container vs running it as <code>root</code>, which can hae security implications.</p> <p>Example:</p> <pre><code># Create a user 'appuser' and set it as the current user\nRUN adduser --disabled-password --gecos '' appuser\nUSER appuser\n</code></pre>"},{"location":"ex188/01-implement-images-using-podman/#syntax","title":"Syntax","text":"<p><code>USER &lt;user&gt;</code> Sets the user for subsequent commands. <code>&lt;user&gt;</code> can be a user name or UID.</p> <p><code>USER &lt;user&gt;:&lt;group&gt;</code> Sets both the user and group for subsequent commands. <code>&lt;group&gt;</code> can be a group name or GID.</p>"},{"location":"ex188/01-implement-images-using-podman/#understand-security-related-topics","title":"Understand security-related topics","text":"<ol> <li> <p>Image Security</p> <p>Trusted Sources: Use container images from trusted sources, such as official images on Docker Hub or other well-known registries. Be cautious with third-party images, as they may contain vulnerabilities or malicious code. Minimal Base Images: Use minimal base images (like Alpine Linux) that contain only the essential packages, reducing the attack surface. Vulnerability Scanning: Regularly scan container images for vulnerabilities using tools like Clair, Trivy, or Docker's own scanning features. Image Signing and Verification: Implement image signing and verification to ensure the integrity of the images. Tools like Docker Content Trust (DCT) can be used for this purpose.</p> </li> <li> <p>Secure Building of Images</p> <p>Dockerfile Best Practices: Follow best practices when writing Dockerfiles, such as avoiding the use of the root user, using multi-stage builds to minimize the image size, and removing unnecessary tools and files. Secrets Management: Avoid embedding secrets (like passwords and API keys) in image layers. Use secure mechanisms like Docker secrets or external secrets management tools.</p> </li> <li> <p>Runtime Security</p> <p>Container Isolation: Ensure containers are properly isolated from each other and from the host system. Use user namespaces to segregate container processes. Resource Limits: Implement resource limits (CPU, memory, etc.) to prevent denial-of-service (DoS) attacks. Read-Only File systems: Where possible, use read-only file systems for containers to prevent unwanted changes.</p> </li> <li> <p>Network Security</p> <p>Port Exposure: Be cautious about exposing container ports. Expose only necessary ports and use firewall rules to restrict access. Secure Networking: Use encrypted communication (TLS/SSL) for sensitive data. Consider network segmentation using Docker networks or Kubernetes namespaces to isolate container groups.</p> </li> <li> <p>Monitoring and Logging</p> <p>Audit Logs: Enable and monitor audit logs for container activity. Tools like Falco can help in detecting and alerting on suspicious container behavior. Anomaly Detection: Implement anomaly detection systems to catch unusual activities that could indicate a security breach.</p> </li> <li> <p>Compliance and Governance</p> <p>Regulatory Compliance: Ensure your container deployment complies with relevant industry standards and regulations (like GDPR, HIPAA, PCI-DSS). Image Lifecycle Management: Implement policies for image retention, updating, and disposal to ensure that containers are always running the latest and most secure versions.</p> </li> <li> <p>Updating and Patch Management</p> <p>Regular Updates: Regularly update and patch container images, dependencies, and the host system to mitigate newly discovered vulnerabilities. Immutable Tags: Avoid using mutable tags like latest for base images; instead, use specific version numbers to ensure consistency and traceability.</p> </li> </ol>"},{"location":"ex188/01-implement-images-using-podman/#understand-the-differences-and-applicability-of-cmd-vs-entrypoint-instructions","title":"Understand the differences and applicability of <code>CMD</code> vs. <code>ENTRYPOINT</code> instructions","text":"<p><code>CMD</code> and <code>ENTRYPOINT</code> are two commands in Dockerfile that are often used to define the default behavior of a Docker container when it starts. While they appear similar, they have different purposes and behaviors.</p> <p><code>CMD</code></p> <ul> <li>Purpose: CMD specifies the default command to run when a container starts. It is intended to provide defaults for an executing container.  </li> <li>Flexibility: If you run the container and pass in arguments, those arguments will replace the default specified in the CMD.</li> <li>Syntax Variations:</li> <li>Shell form: <code>CMD command param1 param2</code></li> <li>Exec form: <code>CMD [\"command\", \"param1\", \"param2\"]</code></li> <li>Use Case: Use CMD when you need to provide a default command and/or parameters that users can easily override when starting a container.</li> </ul> <p><code>ENTRYPOINT</code></p> <ul> <li>Purpose: <code>ENTRYPOINT</code> configures a container to run as an executable. It allows you to set the base command which gets executed every time the container starts.</li> <li>Consistency: Unlike <code>CMD</code>, if you pass arguments to the container at runtime, they are appended to the ENTRYPOINT command.</li> <li>Syntax Variations:</li> <li>Shell form: <code>ENTRYPOINT command param1 param2</code></li> <li>Exec form (preferred for signal handling): <code>ENTRYPOINT [\"command\", \"param1\", \"param2\"]</code></li> <li>Use Case: Use ENTRYPOINT when you want to configure your container to run as a specific executable (like a web server, database, etc.) and you don\u2019t want the base command to be easily overridden.</li> </ul> <p>You can also combine the two:</p> <pre><code>ENTRYPOINT [\"executable\"]\nCMD [\"param1\", \"param2\"]\n</code></pre> <p>Here, <code>executable</code> will always run when the container starts, and it will use <code>param1</code> and <code>param2</code> as default parameters unless overridden.</p>"},{"location":"ex188/01-implement-images-using-podman/#understand-entrypoint-instruction-with-param","title":"Understand ENTRYPOINT instruction with param","text":"<ul> <li>Syntax Variations:</li> <li>Shell form: <code>ENTRYPOINT command param1 param2</code></li> <li>Exec form (preferred for signal handling): <code>ENTRYPOINT [\"command\", \"param1\", \"param2\"]</code></li> </ul>"},{"location":"ex188/01-implement-images-using-podman/#understand-when-and-how-to-expose-ports-from-a-containerfile","title":"Understand when and how to expose ports from a Containerfile","text":"<p><code>EXPOSE</code> is used to define network services offered by the resulting container. When a container runs applications that listen on specific ports for incoming connections, we define these with <code>EXPOSE</code> so external applications/clients can access these services.</p> <p>Unless explicitly defined, TCP is assumed.</p> <p>Examples:</p> <pre><code># Listen on port 80 (TCP)\nEXPOSE 80\n</code></pre> <pre><code># Listen on ports 80 and 443 (TCP)\nEXPOSE 80 443\n</code></pre> <pre><code># Listen on port 8000 (UDP)\nEXPOSE 8000/udp\n</code></pre>"},{"location":"ex188/01-implement-images-using-podman/#understand-and-use-environment-variables-inside-images","title":"Understand and use environment variables inside images","text":"<p>Environment variables are primarily used to manage configurations settings for applications running inside a container. They provide a way to inject configuration data into a container. This can include database connection settings, external API keys, or any other configuration that you might want to change without modifying the container image.</p> <p>To define an environment variable in a container image definition the instruction <code>ENV</code> is used</p>"},{"location":"ex188/01-implement-images-using-podman/#understand-env-instruction","title":"Understand ENV instruction","text":"<pre><code>ENV MY_ENV_VAR myvalue\nENV DB_HOST=localhost DB_PORT=5432\n</code></pre> <p>In this example, <code>MY_ENV_VAR</code> is set to <code>myvalue</code>, and <code>DB_HOST</code> and <code>DB_PORT</code> are set with their respective values.</p> <p>Environment variables can be set at run time as well using in <code>-e</code> flag. For example:</p> <p><code>podman run -e \"VAR_NAME=value nginx:latest</code></p> <p><code>podman run -e \"DB_HOST=prod_db_host nginx:latest</code></p> <pre><code>podman run -d -e \"DB_HOST=prod_db_host\" nginx:latest\npodman exec -it $containerID bash \nroot@099d86767893:/# env | grep DB\nDB_HOST=prod_db_host\n</code></pre>"},{"location":"ex188/01-implement-images-using-podman/#understand-container-volume","title":"Understand container volume","text":"<p>Containers are ephemeral by nature. If no volume is created and used, any and all data is tightly coupled with the lifecycle of the container. Therefore, if the container terminates, data is lost.</p> <p>Within a container image spec, the <code>VOLUME</code> instruction can be used. For example:</p> <pre><code>VOLUME [\"/data\"]\n</code></pre> <p>This commands informs Docker that the container intends to use the specified directory (<code>/data</code>) as a volume. Note - data will not be persisted by simply using this command, but acts as a mount point from the host or another container as a destination.</p> <p>Mounting directories to this volume is typically handled at runtime using <code>podman</code> commands or config files in <code>docker compose</code></p>"},{"location":"ex188/01-implement-images-using-podman/#mount-a-host-directory-as-a-data-volume","title":"Mount a host directory as a data volume","text":"<p>The syntax for mounting a host directory to a volume is as follows:</p> <pre><code>podman run -v /path/on/host:/path/in/container [other options] image_name [command]\n</code></pre> <p>Therefore, using the example above with <code>/data</code> residing on the container, we can mount a host volume</p> <pre><code>podman run -v /home/user/data:/data nginx:latest\n</code></pre>"},{"location":"ex188/01-implement-images-using-podman/#understand-security-and-permissions-requirements-related-to-this-approach","title":"Understand security and permissions requirements related to this approach","text":"<p>Permissions: Ensure that the container's process has the necessary permissions to read and/or write to the mounted directory. This might require adjusting the permissions on the host directory.</p> <p>SELinux: If you are running podman on a system with SELinux enabled (like Fedora), you might need to append :Z or :z to the volume mount flag to properly set the SELinux context for the volume. Use :Z for private mounts and :z for shared mounts.</p> <p>Example:</p> <pre><code>podman run -v /home/user/data:/var/myapp/data:Z nginx:latest\n</code></pre> <p>User and Group IDs: Inside a container, processes run as a specific user and group, identified by User ID (UID) and Group ID (GID). By default, most containers run as the root user (UID 0), but it's a best practice to run processes as a non-root user for security reasons.</p> <p>Host Directory Permissions: The permissions of the host directory determine how the mounted files can be accessed. For example, if the host directory is only writable by the root user, a non-root process inside the container won't be able to write to it unless given appropriate permissions.</p> <p><code>chmod</code> and <code>chown</code> commands can be used to change the permissions on the host system so that the container process has the correct access.</p>"},{"location":"ex188/01-implement-images-using-podman/#understand-the-lifecycle-and-cleanup-requirements-of-this-approach","title":"Understand the lifecycle and cleanup requirements of this approach","text":"<p>When mounting a directory from the host system to a container, the data is persisted outside of the lifecycle of the container. If the container exits, the data remains. Any data created from the container will be reflected in the directory and vise-versa.</p>"},{"location":"ex188/02-manage-images/","title":"Manage images","text":""},{"location":"ex188/02-manage-images/#understand-private-registry-security","title":"Understand private registry security","text":"<p>Several aspects govern private registry security and can be categorized into the following:</p>"},{"location":"ex188/02-manage-images/#registry-authentication-and-authorization","title":"Registry Authentication and Authorization","text":"<ul> <li> <p>Credentials: Access to private registries is typically controlled through username and password credentials. Podman needs to be configured with these credentials to access and interact with the registry.</p> </li> <li> <p>Credential Storage: Podman can store registry credentials securely using the <code>podman login</code> command. This command stores encoded credentials in a file (<code>$XDG_RUNTIME_DIR/containers/auth.json</code> or <code>~/.docker/config.json</code>) on the user's machine.</p> </li> <li> <p>Authorization: This is largely configured at the container registry level, the associated user(s) will be grated granular access to perform certain tasks (ie upload image, delete image, etc).</p> </li> </ul>"},{"location":"ex188/02-manage-images/#interact-with-many-different-registries","title":"Interact with many different registries","text":"<p>When you pull, push, or tag images with Podman, you can specify which registry to interact with by including the registry's URL in the image's name. The general format is <code>registry-url/repository-name/image-name:tag</code>.</p> <p>Example of pulling from a specific registry:</p> <pre><code>podman pull myregistry.com/myimage:latest\n</code></pre> <p>Example of pushing to a specific registry:</p> <pre><code>podman push myimage:latest myregistry.com/myimage:latest\n</code></pre> <p>For private registries, or registries that require authentication, use the podman login command. This command will prompt for a username and password and store the credentials securely.</p> <pre><code>podman login myregistry.com\n</code></pre>"},{"location":"ex188/02-manage-images/#using-multiple-registry-configurations","title":"Using multiple registry configurations","text":"<p>You might want to configure Podman to use multiple registries for pulling images, searching, etc. This can be done by editing the Podman configuration file, typically found at <code>/etc/containers/registries.conf</code>.</p> <p>Example config:</p> <pre><code>[[registry]]\nlocation = \"myregistry.com\"\ninsecure = false\nblocked = false\n\n[[registry]]\nlocation = \"otherregistry.com\"\ninsecure = false\nblocked = false\n</code></pre>"},{"location":"ex188/02-manage-images/#understand-and-use-image-tags","title":"Understand and use image tags","text":"<p>Image tags serve a number of important purposes:</p>"},{"location":"ex188/02-manage-images/#version-control-of-images","title":"Version control of Images","text":"<ul> <li> <p>Identifying Versions: Tags are used to identify different versions of the same container image. This allows for version control, where you can have multiple versions of an image, each tagged differently.</p> </li> <li> <p>Semantic Versioning: Tags often follow semantic versioning (e.g., <code>2.1</code>, <code>2.1.3</code>) to indicate the version of the software or application contained in the image.</p> </li> </ul>"},{"location":"ex188/02-manage-images/#environment-specificity","title":"Environment Specificity","text":"<ul> <li>Differentiating Environments: Tags can be used to differentiate between environments like <code>development</code>, <code>testing</code>, <code>staging</code>, and <code>production</code>. For example, an image could be tagged as <code>myapp:prod</code> for production and <code>myapp:dev</code> for development.</li> </ul>"},{"location":"ex188/02-manage-images/#push-and-pull-images-from-and-to-registries","title":"Push and pull images from and to registries","text":"<p>Given the following <code>Dockerfile</code></p> <pre><code>FROM nginx:latest\n\nVOLUME /site-data\n\nWORKDIR /usr/src/app\n\nEXPOSE 80\n</code></pre> <p>We can <code>build</code>, <code>tag</code> and <code>push</code> it like so:</p> <pre><code>podman build /home/david/Downloads/podman/ --tag quay.io/myimage:0.1\npodman push quay.io/myimage:0.1\n\n# If auth is required\n\npodman push quay.io/myimage:0.1 --creds USERNAME:PASSWORD\n</code></pre> <p>To pull images:</p> <pre><code>podman pull nginx:latest\n</code></pre>"},{"location":"ex188/02-manage-images/#back-up-an-image-with-its-layers-and-meta-data-vs-backup-a-container-state","title":"Back up an image with its layers and meta data vs. backup a container state","text":"<p>A container is a running instance of an image, therefore approaches to back up differ between the two</p> <p>To back up an image:</p> <pre><code>podman save --quiet -o myimage.tar imageID\npodman save --format docker-dir -o ubuntu-dir ubuntu\npodman save &gt; alpine-all.tar alpine:latest\n</code></pre> <p>To restore:</p> <pre><code>podman load -i myimage.tar\n</code></pre> <p>In summary, backing up an image is like saving a recipe, while backing up a container's state is like preserving a meal that's already been cooked. Each serves different purposes and comes with its own set of considerations and methodologies.</p> <p>Backing up a running container primarily involves backing up any attached volumes or using specific application level tooling (ie <code>mysqldump</code>).</p> <p>If applicable, <code>podman volume export</code> can also be used.</p>"},{"location":"ex188/03-run-containers-locally-using-podman/","title":"Run containers locally using Podman","text":""},{"location":"ex188/03-run-containers-locally-using-podman/#get-container-logs","title":"Get container logs","text":"<p><code>podman logs $ContainerID</code> can be ued to retrieve container logs.</p> <p>Can be redirected to an output - ie <code>podman logs ebe &gt; logs.txt</code></p>"},{"location":"ex188/03-run-containers-locally-using-podman/#listen-to-container-events-on-the-container-host","title":"Listen to container events on the container host","text":"<p><code>podman events</code> can be used to accomplish this.</p> <p>Examples:</p> <pre><code>#Get all events from all containers\npodman events\n</code></pre> <pre><code>#Get events from a specific container\npodman events --filter container=my-container\n</code></pre> <pre><code>#Get events by event type (e.g., create, start, stop, remove):\npodman events --filter event=start\n</code></pre> <pre><code>#Get events by time range\npodman events --since 10m --until 5m\n</code></pre>"},{"location":"ex188/03-run-containers-locally-using-podman/#use-podman-inspect","title":"Use Podman inspect","text":"<p><code>podman inspect</code> can be used against multiple object types, ie:</p> <p><code>podman inspect [options] {CONTAINER|IMAGE|POD|NETWORK|VOLUME} [...]</code></p> <p>For example, to inspect an image:</p> <pre><code>podman inspect a6bd71f48f68\n</code></pre>"},{"location":"ex188/03-run-containers-locally-using-podman/#specifying-environment-parameters","title":"Specifying environment parameters","text":"<p>At runtime, <code>-e or --env</code> can be used to specify an environment variable.</p> <pre><code>podman run -e \"MYVAR=myvalue\" &lt;image&gt;\n</code></pre> <p>For multiple environment variables, repear the <code>-e</code> flag:</p> <pre><code>podman run -e \"VAR1=value1\" -e \"VAR2=value2\" &lt;image&gt;\n</code></pre> <p>Environment variables can also be loaded from a file:</p> <pre><code>podman run --env-file myenvfile.env &lt;image&gt;\n</code></pre> <p><code>-e</code> can also be used to overwrite an environment variable defined in the container image.</p>"},{"location":"ex188/03-run-containers-locally-using-podman/#expose-public-applications","title":"Expose public applications","text":"<p>Exposing applications using Podman involves mapping ports from the container to the host system. This way, we can access services running inside the container from outside the host machine. There's a number of ways to achieve this:</p> <pre><code>#Expose a single port from the host system and map it to the container. In this example, map port 5000 from the host to port 80 in the container\n#Format is -p &lt;host-port&gt;&lt;container-port&gt;\n\npodman run -d -p 5000:80 nginx\ncurl localhost:5000\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;Welcome to nginx!&lt;/title&gt;\n</code></pre> <p>To expose multiple ports, follow the same pattern for specifying multiple environment variables, ie multiple <code>-p</code> flags:</p> <pre><code>podman run -d -p 5000:80 -p 6000:443 nginx\n</code></pre> <p>TCP is assumed as the port type, to specify UDP:</p> <pre><code>podman run -p 5000:5000/udp &lt;image&gt;\n</code></pre> <p>To expose a range of ports:</p> <pre><code>podman run -p 8000-8005:8000-8005 &lt;image&gt;\n</code></pre> <p>In systems with multiple interfaces, we can specify one the hosts IP addresses in the binding:</p> <pre><code>podman run -p 172.16.10.45:80:80 nginx\n</code></pre>"},{"location":"ex188/03-run-containers-locally-using-podman/#get-application-logs","title":"Get application logs","text":"<p>Container logs (managed by Podman) give you a view of what is happening at the container level, application logs (managed by the application itself) provide insights into the behavior of the application inside the container.</p> <p>With Container logs, these can be accessed by <code>podman logs [container_name_or_id]</code>. This will capture whatever the main process writes to stdout and stderr.</p> <p>Application logs may do the same, or write to a file / access a logging aggregator directly. This is dependent on the configuration of the containers application.</p> <p>For example, if a container writes to <code>/var/log/app.log</code>, these won't be shown in <code>podman logs</code>. To retrieve this, we'd need to either mount the directory to the host, or exec into the container to view:</p> <pre><code>podman exec -it [container_name_or_id] bash\ncat /var/log/app.log\n</code></pre> <p>Or as a one-liner</p> <pre><code>podman exec -it [container_name_or_id] cat var/log/dpkg.log\n</code></pre>"},{"location":"ex188/03-run-containers-locally-using-podman/#inspect-running-applications","title":"Inspect running applications","text":"<p>There are a number of commands we can use to inspect a running application/</p>"},{"location":"ex188/03-run-containers-locally-using-podman/#container-details","title":"Container details","text":"<p><code>podman inspect [container_name_or_id]</code> can be used to get information about a container, including its configuration, state, network sections and more.</p>"},{"location":"ex188/03-run-containers-locally-using-podman/#container-logs","title":"Container logs","text":"<p><code>podman logs [container_name_or_id]</code> can be used to get everything that has been written to <code>stderr</code> and <code>stdout</code>.</p>"},{"location":"ex188/03-run-containers-locally-using-podman/#container-processes","title":"Container processes","text":"<p><code>podman top [container_name_or_id]</code> can be used to view the running processes inside a container.</p>"},{"location":"ex188/03-run-containers-locally-using-podman/#container-resources","title":"Container resources","text":"<p><code>podman stats</code> can be used to view resource usage of containers, such as CPU, memory, network IO, Disk IO, etc.</p>"},{"location":"ex188/03-run-containers-locally-using-podman/#container-shell","title":"Container shell","text":"<p><code>podman exec -it [container_name_or_id] /bin/bash</code> can be used if the container has been built with a shell installed (not all will). Once a shell has been opened, you can inspect the container.</p>"},{"location":"ex188/03-run-containers-locally-using-podman/#container-health-check","title":"Container health check","text":"<p><code>podman healthcheck run [container_name_or_id]</code> can be used to manually trigger a health check, <code>podman inspect [container_name_or_id]</code> can be used to view the results after.</p>"},{"location":"ex188/03-run-containers-locally-using-podman/#container-filesystem-changes","title":"Container filesystem changes","text":"<p><code>podman diff [container_name_or_id]</code> can be used to identify what changes have been made by the running application to the local filesystem.</p>"},{"location":"ex188/04-run-multi-container-applications-with-podman/","title":"Run multi-container applications with Podman","text":""},{"location":"ex188/04-run-multi-container-applications-with-podman/#create-application-stacks","title":"Create application stacks","text":"<p>Broadly speaking, application stacks involve the use of multiple containers that work together to form a complete application system. This can be accomplished in two different ways - Podman Pods and Podman-compose, as detailed below.</p>"},{"location":"ex188/04-run-multi-container-applications-with-podman/#using-podman-pods","title":"Using Podman Pods","text":"<p>A podman <code>pod</code> is a group of one or more containers that share the same network namespace, amongst other resources.</p> <p>To create a Podman pod:</p> <pre><code>podman pod create --name mypod -p 8080:80\n</code></pre> <p>Note: we don't have anything running this pod, it's a shell.  We'll add a <code>nginx</code> container inside this pod:</p> <pre><code>podman run -d --pod mypod nginx\n</code></pre> <p>Which we can then access by <code>curl localhost:8080</code></p> <p>To add a second container to this pod:</p> <p><code>podman run -d --pod mypod redis</code></p> <p>Which we can inspect with</p> <pre><code>podman pod ps\n\nPOD ID        NAME        STATUS      CREATED        INFRA ID      # OF CONTAINERS\n6babca889ba2  mypod       Running     5 minutes ago  a45cc929c682  3\n</code></pre> <p>Note: it states 3 containers because of the <code>pause</code> container.  </p>"},{"location":"ex188/04-run-multi-container-applications-with-podman/#using-podman-compose","title":"Using Podman-compose","text":"<p><code>podman-compose</code> is a tool designed to help manage multi container applications with Podman. It works in a similar way to Docker Compose, but is tailored for Podman.</p> <p><code>podman-compose</code> is not a part of the main <code>podman</code> binary, therefore it is installed separately.</p> <p><code>podman-compose</code> uses the same <code>docker-compose.yml</code> file format as Docker compose</p> <p>Within a <code>docker-compose.yml</code> file we specify services, networks and volumes in <code>yaml</code> format. Each service corresponds to a container with its own configuration, such as <code>image</code>, <code>ports</code>, <code>volumes</code>, etc.</p> <p>Example full stack application (Frontend, Backend and Database):</p> <pre><code>version: '3'\nservices:\n  frontend:\n    build: ./frontend\n    ports:\n      - \"3000:3000\"\n    depends_on:\n      - backend\n\n  backend:\n    build: ./backend\n    ports:\n      - \"5000:5000\"\n    environment:\n      - DB_URL=mongodb://db:27017/myapp\n    depends_on:\n      - db\n\n  db:\n    image: mongo:latest\n    volumes:\n      - db_data:/data/db\n\nvolumes:\n  db_data: {}\n</code></pre> <p>Breaking this down:</p> <p>Latest version of docker/podman compose files:</p> <pre><code>version: '3'\n</code></pre> <p>Where we define our services, or related containers:</p> <pre><code>services:\n  frontend:\n  backend:\n  db:\n</code></pre> <p>We must either specify a <code>image</code> and/or <code>build</code> instruction.</p> <ul> <li><code>image</code> - Pull an pre-built image from a registry</li> <li><code>build</code> - Specify a location of a <code>dockerfile</code> to build an image from, and use that. Podman uses a default naming convention to tag the built image. This convention is based on the directory name where the docker-compose.yml file is located, along with the service name defined in the compose file, followed by a tag that is usually latest.</li> <li>if using both <code>image</code> and <code>build</code>, podman will build the image with the name and optional tag.</li> </ul> <pre><code>version: '3'\nservices:\n  frontend:\n    build: ./frontend\n\n  backend:\n    build: ./backend\n\n  db:\n    image: mongo:latest\n</code></pre> <p>Specify external ports to access the applications on. No need to expose the DB service externally:</p> <pre><code>version: '3'\nservices:\n  frontend:\n    build: ./frontend\n    ports:\n      - \"3000:3000\"\n\n  backend:\n    build: ./backend\n    ports:\n      - \"5000:5000\"\n\n  db:\n    image: mongo:latest\n\nvolumes:\n  db_data: {}\n</code></pre> <p>Specify any environment variables and dependencies with <code>depends_on</code></p> <pre><code>version: '3'\nservices:\n  frontend:\n    build: ./frontend\n    ports:\n      - \"3000:3000\"\n    depends_on:\n      - backend\n\n  backend:\n    build: ./backend\n    ports:\n      - \"5000:5000\"\n    environment:\n      - DB_URL=mongodb://db:27017/myapp\n    depends_on:\n      - db\n\n  db:\n    image: mongo:latest\n</code></pre> <p>Followed by any persistent volumes:</p> <pre><code>version: '3'\nservices:\n  frontend:\n    build: ./frontend\n    ports:\n      - \"3000:3000\"\n    depends_on:\n      - backend\n\n  backend:\n    build: ./backend\n    ports:\n      - \"5000:5000\"\n    environment:\n      - DB_URL=mongodb://db:27017/myapp\n    depends_on:\n      - db\n\n  db:\n    image: mongo:latest\n    volumes:\n      - db_data:/data/db\n\nvolumes:\n  db_data: {}\n</code></pre>"},{"location":"ex188/04-run-multi-container-applications-with-podman/#understand-container-dependencies","title":"Understand container dependencies","text":"<p>From the example above, <code>depends_on</code> is used to define dependencies between containers. A typical example includes a backend/frontend service and a database.</p>"},{"location":"ex188/04-run-multi-container-applications-with-podman/#working-with-environment-variables","title":"Working with environment variables","text":"<p>From the example above, <code>environment</code> is used to define environment variables used by the containers which can influence application behavior.</p>"},{"location":"ex188/04-run-multi-container-applications-with-podman/#working-with-secrets","title":"Working with secrets","text":"<p><code>environment</code> variables can be used to parse secret information however, it is not secure as it's visible in plain text:</p> <pre><code>version: '3'\nservices:\n  web:\n    image: my-web-app\n    environment:\n      DATABASE_PASSWORD: mysecretpassword\n</code></pre> <p>Another way to accomplish this is to create a file that contains environment variable definitions and reference it:</p> <pre><code>version: '3'\nservices:\n  web:\n    image: my-web-app\n    env_file:\n      - web.env\n</code></pre> <p>In web.env, you'd have:</p> <pre><code>DATABASE_PASSWORD=mysecretpassword\n</code></pre>"},{"location":"ex188/04-run-multi-container-applications-with-podman/#working-with-volumes","title":"Working with volumes","text":""},{"location":"ex188/04-run-multi-container-applications-with-podman/#named-volumes","title":"Named Volumes","text":"<p>Here, db_data is a named volume that is mounted into the postgres container at /var/lib/postgresql/data.</p> <pre><code>version: '3'\nservices:\n  db:\n    image: postgres\n    volumes:\n      - db_data:/var/lib/postgresql/data\n\nvolumes:\n  db_data: {}\n</code></pre> <p>Note: Podman stores named volumes in a specific directory on the host system. This directory is usually under <code>/var/lib/containers/storage/volumes</code> (or a similar path, depending on your Podman configuration and installation). Within this directory, each named volume has its own subdirectory.</p> <p>Named volumes can be managed with <code>podman volume</code>.</p>"},{"location":"ex188/04-run-multi-container-applications-with-podman/#bind-mounts","title":"Bind Mounts","text":"<p>Bind mounts are used to mount specific paths on the host to the container. They are useful for development purposes where you want to reflect code changes immediately in the container.</p> <pre><code>version: '3'\nservices:\n  app:\n    image: my-app\n    volumes:\n      - ./app:/usr/src/app\n</code></pre> <p>In this example, the <code>./app</code> directory on the host is mounted into the <code>my-app</code> container at <code>/usr/src/app</code>.</p>"},{"location":"ex188/04-run-multi-container-applications-with-podman/#anonymous-volumes","title":"Anonymous Volumes","text":"<p>Anonymous volumes are not named and are often used for temporary or throwaway data that doesn't need to be persisted after the container is removed.</p> <pre><code>version: '3'\nservices:\n  app:\n    image: my-app\n    volumes:\n      - /usr/src/app\n</code></pre>"},{"location":"ex188/04-run-multi-container-applications-with-podman/#working-with-configuration","title":"Working with configuration","text":"<p>With all configuration sections complete.  We can start up with:</p> <p><code>podman-compose up -d</code></p> <p>Note: <code>-d</code> runs it in detached mode.</p> <p>Stopping and removing:</p> <p><code>podman-compose down</code></p> <p>If in doubt - <code>podman-compose --help</code></p>"},{"location":"ex188/05-troubleshoot-containerized-applications/","title":"Troubleshoot containerized applications","text":""},{"location":"ex188/05-troubleshoot-containerized-applications/#understand-the-description-of-application-resources","title":"Understand the description of application resources","text":"<p>Understanding the description of application resources involves leveraging a number of <code>podman</code> commands.</p> <p>Basic container inspection can be done with <code>podman inspect [container_name_or_id]</code> from this we can get</p> <ul> <li>ID</li> <li>Args</li> <li>Image</li> <li>Pod</li> <li>Volume</li> <li>Network</li> </ul>"},{"location":"ex188/05-troubleshoot-containerized-applications/#get-application-logs","title":"Get application logs","text":"<p><code>podman logs container_name_or_id]</code> if the container writes to <code>stdout</code> / <code>stderr</code>. Otherwise it may log to a file or directly to an external logging aggregator</p>"},{"location":"ex188/05-troubleshoot-containerized-applications/#inspect-running-applications","title":"Inspect running applications","text":"<p><code>podman inspect</code> can also be used to accomplish this. IE to identify any exposed ports.</p> <p>Health checks can be run by executing <code>podman healthcheck run [container_name_or_id]</code>. Note, this requires health checks to be configured on the container. An example of which can be defined in the compose file:</p> <pre><code>healthcheck:\n  test: [\"CMD\", \"curl\", \"-f\", \"http://localhost\"]\n  interval: 1m30s\n  timeout: 10s\n  retries: 3\n  start_period: 2m\n</code></pre> <p>Changes to the containers filesystem can be identified with <code>podman diff [container_name_or_id]</code></p>"},{"location":"ex188/05-troubleshoot-containerized-applications/#connecting-to-running-containers","title":"Connecting to running containers","text":"<p><code>podman exec -it [container_name_or_id] /bin/sh</code> (change <code>sh</code> to an appropriate shell). This will create a interactive shell directly inside the container subsequent commands can be run.</p> <p>If we know exactly what we need to run in the container and log the output to <code>stdout</code>, we can use</p> <pre><code>podman exec [container_name_or_id] [command]\n</code></pre> <p>For example:</p> <pre><code>podman exec [container_name_or_id] ls /path/to/directory\n</code></pre> <p>We can also specify a specific user to run the command as, using the <code>user</code> flag:</p> <pre><code>podman exec --user [username] [container_name_or_id] [command]\n</code></pre>"},{"location":"ex188/readme/","title":"Exam Info","text":"<p>Reference: https://www.redhat.com/en/services/training/ex188-red-hat-certified-specialist-containers-exam</p>"},{"location":"ex188/readme/#objectives","title":"Objectives","text":""},{"location":"ex188/readme/#1-implement-images-using-podman","title":"1 - Implement images using Podman","text":"<ul> <li>Understand and use FROM (the concept of a base image) instruction.</li> <li>Understand and use RUN instruction.  </li> <li>Understand and use ADD instruction.  </li> <li>Understand and use COPY instruction.  </li> <li>Understand the difference between ADD and COPY instructions.  </li> <li>Understand and use WORKDIR and USER instructions.  </li> <li>Understand security-related topics.  </li> <li>Understand the differences and applicability of CMD vs. ENTRYPOINT instructions.  </li> <li>Understand ENTRYPOINT instruction with param.  </li> <li>Understand when and how to expose ports from a Containerfile.  </li> <li>Understand and use environment variables inside images.  </li> <li>Understand ENV instruction.  </li> <li>Understand container volume.  </li> <li>Mount a host directory as a data volume.  </li> <li>Understand security and permissions requirements related to this approach.  </li> <li>Understand the lifecycle and cleanup requirements of this approach.  </li> </ul>"},{"location":"ex188/readme/#2-manage-images","title":"2 - Manage images","text":"<ul> <li>Understand private registry security.</li> <li>Interact with many different registries.</li> <li>Understand and use image tags</li> <li>Push and pull images from and to registries.</li> <li>Back up an image with its layers and meta data vs. backup a container state.</li> </ul>"},{"location":"ex188/readme/#3-run-containers-locally-using-podman","title":"3 - Run containers locally using Podman","text":"<ul> <li>Run containers locally using Podman</li> <li>Get container logs.</li> <li>Listen to container events on the container host.</li> <li>Use Podman inspect.</li> <li>Specifying environment parameters.</li> <li>Expose public applications.</li> <li>Get application logs.</li> <li>Inspect running applications.</li> </ul>"},{"location":"ex188/readme/#4-run-multi-container-applications-with-podman","title":"4 - Run multi-container applications with Podman","text":"<ul> <li>Create application stacks</li> <li>Understand container dependencies</li> <li>Working with environment variables</li> <li>Working with secrets</li> <li>Working with volumes</li> <li>Working with configuration</li> </ul>"},{"location":"ex188/readme/#5-troubleshoot-containerized-applications","title":"5 - Troubleshoot containerized applications","text":"<ul> <li>Understand the description of application resources</li> <li>Get application logs</li> <li>Inspect running applications</li> <li>Connecting to running containers</li> </ul>"}]}